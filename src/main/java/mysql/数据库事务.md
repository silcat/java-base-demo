##参考文档
* https://notes.diguage.com/mysql/#schema-speed-up-alter

## 数据库组件结构
````
1.连接池组建
2. 管理服务和工具组建
3. SQL接口组件（SQL Interface）
4. 查询分析器（Parser）
5. 优化器组件（OpTImizer）
6. 缓冲组件（Cache & Buffer）
7. 插件式存储引擎（Pluggable Storage Engines）
8. 物理文件 （File Sysgtem & Logs）
````
````
1.数据库是文件集合，数据库实例是程序，两者通过插件式的存储引擎交互，而对开发人员通过数据库实例来操作数据库
````
## 数据库需要解决的问题
* 数据库的事务隔离是为解决事务不隔离而产生的脏读、幻读、不可重复读等问题。
* 而数据库事务的隔离性是通过锁机制和mvcc来实现的
## 以下分析基于innodb存储引擎   
##ACID 
* ![ACID](img/ACID.png)
* ：只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！
##数据库事务问题
* 脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
* 丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。
* 不可重复读（Unrepeatable read）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
* 幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。
* 幻读与不可用重复读的区别：幻读是因为insert导致的，不可以重复读是因为更新导致;
##事务隔离级别
  * Read Uncommitted(未提交读)
    * 事务可以读取其他事务未提交的数据
    * 出现脏读(Dirty Read)
  * Read Committed(提交读)
    * 一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。
    * 解决脏读
    * 导致幻读，不可重复
  * Repeatable Read(可重复读)
    * 在同一个事务内的查询都是事务开始时刻一致的
    * 解决不可重复读，仍存在幻读
    * mysql数据库可重复读隔离级别解决了幻读问题。
  * Serializable(可串行化)
    * Serializable 是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读问题。简单来说，Serializable 会在读取的每一行数据上都加锁，所以导致大量的超时和锁争用的问题。实际中，极少使用。
  * Repeatable Read(可重复读) 是 MySQL 默认事务隔离级别。
##MySQL隔离级别原理与实现
* MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。
##MVVC
* 什么是MVVC
    ````
    MVCC (Multi-Version Concurrency Control) (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)是一种基于多版本的并发控制协议，只有在InnoDB引擎下存在。
    MVCC是为了实现事务的隔离性，通过版本号，避免同一数据在不同事务间的竞争，你可以把它当成基于多版本号的一种乐观锁。
    这种乐观锁只在事务级别未提交锁和已提交锁时才会生效。
    MVCC最大的好处，相信也是耳熟能详：读不加锁，读写不冲突。
    在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能。具体见下面介绍。
    ````
* MVCC的实现机制
  * InnoDB在每行数据都增加两个隐藏字段，一个记录创建的版本号，一个记录删除的版本号;
  * 在每开启一个事务时会生成一个事务的版本号和该数据行的快照(临时表)。  
  * 可重复读和不可重复读的关键，可重复读是在事务开始的时候生成一个当前事务全局性的快照，而读提交则是每次执行语句的时候都重新生成一次快照。 
  * 事务提交成功，将新的版本号更新到此数据行中。
# mysql的锁机制
## 表锁
* 表锁由 MySQL Server 实现，行锁则是存储引擎实现。
* 开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
* 表锁使用的是一次性锁技术，在会话开始的地方使用 lock 命令将后续需要用到的表都加上锁，在表释放前，只能访问这些加锁的表，不能访问其他表，直到最后通过 unlock tables 释放所有表锁。
* 加表锁情况
  * DDL 语句时会对整个表进行加锁(CREATE、ALTER、DROP);
  * 在用 LOCK TABLES 对 InnoDB 表加锁时要注意，要将 AUTOCOMMIT 设为 0，否则MySQL 不会给表加锁；
  * 事务结束前，不要用 UNLOCK TABLES 释放表锁，因为 UNLOCK TABLES会隐含地提交事务  
  

````
lock table user read(write); # 分为读锁和写锁
Query OK, 0 rows affected (0.00 sec)
mysql> select * from user where id = 100; # 成功
mysql> select * from role where id = 100; # 失败，未提前获取该 role的读表锁
mysql> update user  set name = 'Tom' where id = 100; # 失败，未提前获得user的写表锁
mysql> unlock tables; # 显示释放表锁Query OK, 0 rows affected (0.00 sec)
````

## 行锁
* 参考文档
    * https://blog.csdn.net/hekeyer/article/details/104562946
    * https://blog.csdn.net/qq4165498/article/details/76855139
* 行锁是存储引擎实现，不同存储引擎实现行锁方式不同
* innodb的行级锁是依赖于索引实现的
    * 如果走索引实现的增删改会加锁
    * 不走索引可能加表锁    
* InnoDB在事务执行过程中，使用两阶段锁协议：行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。
    ````
    2PL,两阶段加锁协议:主要用于单机事务中的一致性与隔离性。
    2PC,两阶段提交协议:主要用于分布式事务
    ````
* 读锁
     * 共享锁（Share locks，简称 S 锁），加了读锁的记录，所有的事务都可以读取，但是不能修改，并且可同时有多个事务对记录加读锁。
     * 对于普通 SELECT 语句，InnoDB 不会加任何锁
     * 手动加锁
     ````
     共享锁（S)：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。
     排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁
     ````
* 写锁
     * 排他锁（Exclusive locks，简称 X 锁）或独占锁，对记录加了排他锁之后，只有拥有该锁的事务可以读取和修改，其他事务都不可以读取和修改，并且同一时间只能有一个事务加写锁。
     * 对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB会自动给涉及数据集加排他锁（X)；
* 意向锁
    * 意向锁是表级别锁
    * 当事务要在记录上加上读锁或写锁时，要首先在表上加上意向锁。
    * 分为读意向锁（IS 锁）和写意向锁（IX 锁）。
    * 作用：有了意向锁之后，如事务A在申请行锁（写锁）之前，数据库会自动先给事务A申请表的意向排他锁。当事务B去申请表的写锁时就会失败，因为表上有意向排他锁之后事务B申请表的写锁时会被阻塞
    * 意向锁是 InnoDB 自动加的， 不需用户干预。

* 死锁及死锁检测
    * 死锁：互相持有写锁不释放
    ````
    事务A不提交：update t set k = 2 where id =1;                                 update t set k = 2 where id =2;
    事务B不提交：                                 update t set k = 2 where id =2;                                update t set k = 2 where id =1;  
    ````
    * 解决方式
        * 设置超时时间
        * 死锁检测：发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。mysql默认开启死锁检测
             * 不足：新来的被堵住的线程判断死锁是一个时间复杂度是O(n)的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。因此，你就会看到CPU利用率很高，但是每秒却执行不了几个事务。
        * 业务端将事务拆分    
    * 热点数据更新导致的死锁问题解决方案
        * 关闭死锁检测但会出现大量的连接超时(不行)。
        * 控制并发度:基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了。
            * 分布式锁，加入mq队列，通过mq更新热点数据（吞吐量受到影响）
        
##页面锁
* 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般
* 当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。

#实例分析innodb是如何事务事务隔离级别以及由并发导致解决幻读等问题的
* 目前有两个事务A，B对同一个数据执行update操作
* 根据MVVC,开启事务前会创建快照A和快照B，实现事务隔离
* 事务A先执行update操作，会先在表加上写IX 锁，然后在更新数据加上X锁
* 事务B后执行update操作，会等待到事务B提交事务，若等待时间超过超时时间抛出等待异常。
* 可重复读隔离级别可以解决幻读是因为事务开始的时候生成一个当前事务全局性的快照，后续数据从该快照获取。



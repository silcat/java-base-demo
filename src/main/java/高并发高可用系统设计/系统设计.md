#高并发性能指标
* https://www.cnblogs.com/Leo_wl/p/16715842.html
* 响应时间RT(Response-time)就是用户发出请求到用户收到系统处理结果所需要的时间。
* 并发量：同时处理的请求数量
    * 平均并发量 ：总请求/24小时(秒)
    * 峰值并发量 ：平均并发量 * 6
    * 真实并发量 ：总请求/24小时(秒)/24-访问量较少时间段
* 吞吐量
    * 吞吐量指的是系统单位时间内系统处理的请求数量。
    * TPS、QPS都是吞吐量的常用量化指标。
    * QPS（Query Per Second） ：服务器每秒可以执行的查询次数；
    * TPS（Transaction Per Second） ：服务器每秒处理的事务数（这里的一个事务可以理解为客户发出请求到收到服务器的过程）
    * QPS/TPS = 并发数/平均响应时间(RT)
* 系统活跃度   
    * PV：页面浏览量
    * UV：某站点的独立访客
    * DAU：日活跃用户数
    * MAU：月活跃用户数
* Load（系统负载）   
* GMV:只要是订单，不管消费者是否付款、卖家是否发货、是否退货，都可放进 GMV 。 
##DAU,QPS,RT的关系
* 举例：某网站 DAU为 X， 用户日均使用时长 1 小时，RT为0.5s，求并发量和QPS。
    * 总请求量 = DAU * 3600
    * 平均并发量 = 总请求量 / （24 - 8） * 3600
    * QPS = 真实并发量 / 0.5 = DAU / 8
##PV,QPS,RT的关系
* 举例：某网站 PV为 X， 用户日均使用时长 1 小时，RT为0.5s，求并发量和QPS。
    * 总请求量 = PV*0.8
    * 真实并发量 = 总请求量 / 24*0.2 * 3600
    * QPS = 真实并发量 / 0.5 = DAU / 8   
##影响高并发指标的因素
* 最佳线程数     
#压测工具
##ab
* https://www.jianshu.com/p/43d04d8baaf7
* Apache 旗下的一款测试工具，非常实用。
* 提供需要的基本性能指标，但是没有图形化结果，不能监控。因此ab工具可以用作临时紧急任务和简单测试。 
##Jmeter
* https://www.cnblogs.com/stulzq/p/8971531.html
##Sysbench
##tomcat access log
* cat xx.log |grep 'GET /mvc2'|cut -d ' ' -f4|uniq -c|sort -n -r  QPS统计
#常见软件支持QPS
* nginx：30W/10W
* redis：单机可以达到8W
* mysql：4K左右
* tomcat:单机tomcatQPS最多2W左右/0.1W
* kafka: 单机几十万数级QPS
* feign：根据线程池决定
    * https://blog.csdn.net/babylovewei/article/details/105981418#:~:text=Feign%E6%8F%90%E4%BE%9B%E4%BA%86,%E5%85%B7%E4%BD%93%E5%85%B3%E7%B3%BB%E8%A7%81%E4%B8%8B%E8%A1%A8%E3%80%82
#QPS分级
##50QPS以下——小网站
* DAU 400
* 简单的小网站而已，你可以用最简单的方法快速搭建，只要服务器不要太烂就好。
##50～100QPS——DB极限型
* DAU 800
* 大部分的关系型数据库的每次请求大多都能控制在0.01秒左右，即便你的网站每页面只有一次DB请求，那么页面请求无法保证在1秒钟内完成100个请求，
* 这个阶段要考虑做Cache或者多DB负载。无论那种方案，网站重构是不可避免的。
##300～800QPS——带宽极限型
* DAU 6400
* 服务器大多用了IDC提供的“百兆带宽”，这意味着网站出口的实际带宽是8M Byte左右。
* 假定每个页面只有10K Byte，在这个并发条件下，百兆带宽已经吃完。首要考虑是CDN加速／异地缓存，多机负载等技术。
##1000～2000QPS——FORK/SELECT，锁模式极限型
* 好吧，一句话：线程模型决定吞吐量。不管你系统中最常见的锁是什么锁，这个级别下，文件系统访问锁都成为了灾难。这就要求系统中不能存在中央节点，所有的数据都必须分布存储，数据需要分布处理。总之，关键词：分布
##2000QPS以上——C10K极限
#系统设计
* https://github.com/donnemartin/system-design-primer
* 描述使用场景，约束和假设把所有需要的东西聚集在一起，审视问题。不停的提问，以至于我们可以明确使用场景和约束。讨论假设。
  * 谁会使用它？
  * 他们会怎样使用它？
  * 有多少用户？
  * 系统的作用是什么？
  * 系统的输入输出分别是什么？
  * 我们希望处理多少数据？
  * 我们希望每秒钟处理多少请求？
  * 我们希望的读写比率？
* 创造一个高层级的设计，使用所有重要的组件来描绘出一个高层级的设计。
    * 画出主要的组件和连接
    * 证明你的想法
* 设计核心组件
    * 代码功能实现逻辑
* 性能与拓展性
* 延迟与吞吐量
* 可用性与一致性
    * CAP 理论
        * CP - 一致性和分区容错性
        * AP - 可用性和分区容错性(
* 一致模式
    * 弱一致性
    * 最终一致性
    * 强一致性
* 可用模式
    * 故障切换
    * 复制
* 域名系统
* CDN(内容分发网络cdn)
    * CDN 推送
    * CDN 拉取
* 负载均衡器
    * 工作到备用切换（Active-passive）
    * 双工作切换（Active-active）
    * 四层负载均衡
    * 七层负载均衡
    * 水平扩展
* 反向代理（web 服务器）
    * 负载均衡与反向代理
* 应用层
    * 微服务
    * 服务发现
* 数据库
    * 关系型数据库管理系统
        * Master-slave 复制集(#主从复制)
        * Master-master 复制集(#主主复制)
        * 联合
        * 分片
        * 非规范化
        * SQL 调优
    * NoSQL(#nosql)
        * Key-value 存储
        * 文档存储
        * 宽列存储
        * 图数据库
    * SQL 还是 NoSQL
* 缓存
    * 客户端缓存
    * CDN 缓存
    * Web 服务器缓存
    * 数据库缓存
    * 应用缓存
    * 数据库查询级别的缓存
    * 对象级别的缓存
    * 何时更新缓存
        * 缓存模
        * 直写模式
        * 回写模式
        * 刷新
* 异步
    * 消息队列
    * 任务队列
    * 背压机制
* 通讯
    * 传输控制协议（TCP）
    * 用户数据报协议（UDP
    * 远程控制调用协议（RPC）
    * 表述性状态转移（REST 
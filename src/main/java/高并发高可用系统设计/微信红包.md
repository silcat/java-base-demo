#参考文档
* https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650995437&idx=1&sn=fefff4bff3e183d656a2d242e4c0a382&chksm=bdbf02be8ac88ba8d77252cf0279d708633364589a3c14e4e08fbe49e02dcf7ecfac50f141fe&scene=21#wechat_redirect
* https://blog.csdn.net/u011381576/article/details/80056967
* https://github.com/SongLiangChen/distributed_redbag_system
* https://github.com/pleuvoir/redpack
#抢红包流程设计
* 发红包
* 抢红包
* 红包入库
* 查红包
#设计处理难点
* 微信红包业务比普通商品“秒杀”有更海量的并发要求
    * 根据红包ID进行服务分流
        * 将服务划分为不同Set，每组Set中服务共用一个DB
        * Set中的服务服务根据红包ID Hash重新路由到某一个服务
        * 如此便可以将洪流拆分为娟娟溪流
* 单机事务操作中上并发请求数据库抢锁。如多个请求并发请求某一行库存记录
    * 事务中查询库存使用悲观锁（SELECT * FROM table_name WHERE ... FOR UPDATE）
        * 在第一个事务完成提交之前这个锁一直被第一个请求占用，后面的所有请求需要排队等待。同时参与“秒杀”的用户越多，并发进DB的请求越多，请求排队越严重
    * 事务中使用乐观锁更新库存（使用唯一主键等替代乐观锁）   
        * 这个方案解决了“并发请求抢锁”的问题，可以提高DB的并发处理能力。
        * 抢红包乐观锁更新失败会返给用户错误，不符合业务场景
        * 多个事务请求只会有一个成功其他会失败，会带来大数量的无效更新请求、事务回滚，给DB造成不必要的额外压力。
    * 使用分布式事务对请求加锁（同乐观锁） 
    * 内存中更新库存，通过异步方式更新数据库
        * 数据丢失  
    * 将请求放入队列串行处理，避免锁竞争
* 异步处理非核心需求
    * 用户创建红包记录，增减账户的功能可以再抢红包成功后发kafka异步更新    
* 红包生成与金额算法
    * 在发红包时预先生成固定数量红包
    * 实时计算红包
       * 算法：将剩余的钱除以剩余的红包数，然后再乘以2这个范围内取随机数就可以了
       ````
      int rand = (total.get() / count.get()) * 2;
      int price = random.nextInt(rand - 1) + 1; 
       ````    
* 分库分表查询红包信息
    * 冷热数据隔离
        * 创建一个“近期红包数据”的数据库，并且采用单库单表设计， 该库保留近一周或者一月的数据，平时做统计或者后台查看红包列表的时候，读取近期红包数据。
        * 另外还可以按月或者按年生成报表形式存储数据，以后直接查看报表
    * 分库表规则： db_xx.t_y_dd：xx/y是红包ID的hash值后三位，dd的取值范围在01~31，代表一个月天数最多31天。
    * 分表键规则： 红包id保证全局唯一，同时，红包id的最后三位数格式为XXY，代表了它具体落地的数据库。
           
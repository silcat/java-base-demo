#特点
* 实时性 ：你关注的人发了微博信息之后，信息需要在短时间之内出现在你的信息流中。
    * 智能推荐：依赖推荐系统
    * 纯timeline：朋友圈
    * 推送方式
        * 服务推送
        * 客户端拉取
        * 推拉结合
* 高并发 ：信息流是微博的主体模块，是用户进入到微博之后最先看到的模块，因此它的并发请求量是最高的，可以达到每秒几十万次请求。
* 性能 ： 信息流拉取性能直接影响用户的使用体验。微博信息流系统中需要聚合的数据非常多。聚合这么多的数据就需要查询多次缓存、数据库、计数器，而在每秒几十万次的请求下，如何保证在 100ms 之内完成这些查询操作，展示微博的信息流呢？这是微博信息流系统最复杂之处，也是技术上最大的挑战。
* 读写压力大
#实时性  
* 如果产品中是双向关系，那么就采用推模式。
*  如果产品中是单向关系，且用户数少于1000万，那么也采用推模式，足够了。
*  如果产品是单向关系，单用户数大于1000万，那么采用推拉结合模式，这时候可以从推模式演进过来，不需要额外重新推翻重做。
*  永远不要只用拉模式。
*  如果是一个初创企业，先用推模式，快速把系统设计出来，然后让产品去验证、迭代，等客户数大幅上涨到1000万后，再考虑升级为推拉集合模式。
#读写压力大
* mysql读写分离+redisClust
    * 关系存储到mysql
    * 共同关注/活跃粉丝/关注列表存储到redis
* 分布式数据库
    * 天然支持分布式，不需要分库分表
    * Tablestore、Bigtable，TIDB
#如何聚合
##推拉结合
* 仅仅写入到活跃用户，不活跃的用户自己去拉取。
* 就是在线推
* 用户A关注了用户B ，用户B发布动态则将动态推进用户A的feed。
* 用户A的feed使用redis的zset实现，sort为time（记得以毫秒为时间戳))，value为具体的动态 ID（在redis里面全部走ID，修改动态内容也需要修改一处，动态内容可以保存在hash结构里）
* 每个用户维护一个zset保存我发布的动态，一个zset保存我的feed动态，过期时间3~7天看情况而定。
* 全局维护一个在线用户列表，最好是1~3小时未操作或者离线时间不大于3小时的，都当做在线处理。
* 那么，当用户发了一条动态后，后台会有以下这些操作：
    * 在线推： 异步遍历在线的粉丝，将动态ID，添加到粉丝的Feed中。
    * 离线拉： 
        * 我们也开了一个异步线程，对用户进行Feed更新操作，防止用户进入APP后等待拉取时间过长，毕竟关注成千上万的人肯定有（其实万单位以下遍历都很快）。
        * 拉取过程其实就是把自己最后一条Feed的时间戳取出，去遍历关注的人的feed，将大于该时间的ID全部拉取回来。用户进入APP后，刷新即可看到最新操作。
* feed队列设置500条并且设置超时时间，防止占用内存过大。       
##聚合根据feed缓存聚合，超出数据查询数据库。 

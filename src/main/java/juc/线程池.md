#ThreadPoolExecutor
##构造参数
* corePoolSize : 核心线程数定义了最小可以同时运行的线程数量。
* maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
* workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。
* ThreadPoolExecutor其他常见参数:
* keepAliveTime:当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；
* unit : keepAliveTime 参数的时间单位。
* threadFactory :executor 创建新线程的时候会用到。
* handler :饱和策略。关于饱和策略下面单独介绍一下
    * ThreadPoolExecutor.AbortPolicy： 抛出 RejectedExecutionException来拒绝新任务的处理。
    * ThreadPoolExecutor.CallerRunsPolicy： 调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。
    * ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。
    * ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。
##流程
* ![img.png](img/图解线程池实现原理.png)   
##问题一：线程池被创建后里面有线程吗？如果没有的话，你知道有什么方法对线程池进行预热吗？
* 没有，添加任务才会添加worker线程。 prestartallcorethread()可以预热线程。
##核心线程可以被销毁吗
* 核心线程数默认是不会被回收的，如果需要回收核心线程数，需要调用allowCoreThreadTimeOut 该值默认为 false。
##线程池参数设置（常规参考值）
- 高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换
- 并发不高、任务执行时间长的业务要区分开看：
    - 假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务
      - corePoolSize = CPU核数 * 2
    - 假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换
    - 并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）
    - 线程池参数设置
        - corePoolSize = maxPoolSize = tasks*taskcost
        - queueCapacity(队列大小) = (coreSizePool/taskcost)*responsetime（容忍响应时间）
        - allowCoreThreadTimeout = false(是否销毁核心线程：否)
        - keepAliveTime = 60s(默认值)
        - rejectedExecutionHandler 拒绝策略
          - 通过实现 RejectedExecutionHandler 接口扩展：单独启动一个新的临时线程来执行任务。
          - AbortPolicy:直接拒绝并抛出异常
          - CallerRunsPolicy:在调用者线程中（也就是说谁把 r 这个任务甩来的），运行当前被丢弃的任务。

##线程池参数设置（动态调整）    
* 因为同一个服务器可能部署多个线程池（有io，cpu型的，理想很丰满）  
* ThreadPoolExecutor支持在运行期间更改核心线程数与最大线程数。
* 通过apolo线上改配置动态调节，core= max 且 allowCoreThreadTimeout = true
 
          
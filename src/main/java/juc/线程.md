* https://mp.weixin.qq.com/s/yhg5Kxd6AzR-kPpFAE-SdA
#线程状态
##新建状态(New)： 
- 当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行。
##就绪状态(Runnable):
- start()方法返回后，线程就处于就绪状态。
- 一个新创建的线程调用线程的start()方法,当
- 处于就绪状态的线程并不一定立即运行run()方法,线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。
##运行状态(Running)
- 当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法.
##阻塞状态(Blocked)
- 0>所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。
- 1>线程通过调用sleep方法进入睡眠状态；
- 2>线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；
- 3>线程试图得到一个锁，而该锁正被其他线程持有；
- 4>线程在等待某个触发条件；
##死亡状态(Dead)
- 有两个原因会导致线程死亡：1) run方法正常退出而自然死亡，2) 一个未捕获的异常终止了run方法而使线程猝死。
- 为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法。如果是可运行或被阻塞，这个方法返回true； 如果线程仍旧是new状态且不是可运行的， 或者线程死亡了，则返回false.
##状态切换
| 表头                 | 是否释放锁    | 线程状态                  |执行后续代码 | 异常处理  | 继续方式                      |实现方式|
|--------------------|----------|-----------------------| ----  | ----  |---------------------------|  ----  |  
| Object.wait()      | 释放锁      | WAITING/TIMED_WAITING | 可能执行后续代码|中断异常 | Object.notify             |native方法|
| Condition.wait()   | 释放锁      | WAITING/TIMED_WAITING        | 可能执行后续代码|中断异常 | Object.notify             |LockPark.park()|
| LockPark.park()    | 不需要获得锁 | WAITING/TIMED_WAITING |一定执行后续代码 | 不抛异常| unpark()                  |unsafe.park|
| Thread.sleep()     | 不释放      |timed_waiting              |一定执行后续代码 | 中断异常| 阻塞时间到了                    |native方法|
| Thread.yield()     | 不释放      | 可运行                   |一定执行后续代码 | 不抛异常| 等待调度                      |native方法|
| childThread.join() | 不释放      | WAITING/TIMED_WAITING |一定执行后续代码 | 中断异常| 子线程运行完毕                   |native方法|
| Thread.interrupt() | -        | 不影响线程状态               |设置线程中断不影响线程的继续执行| | 调用了wait、join、sleep,抛出中断异常 |native方法|
| synchronized       | - 加锁     | blocked                 |一定执行后续代码 | 中断异常| 线程释放monit关键字              |native方法|
##线程创建
- 继承Thread类或者调用Runnable,callble接口,线程池创建线程
- 异同:覆写Runnable接口实现多线程可以避免单继承局限 b.实现Runnable()可以更好的体现共享的概念
#线程安全
##线程安全级别
###不可变
- 不可变:像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用
- final：final天然的就保障了对象的安全发布；final修饰基本数据类型变量时，变量值不改变；final修饰引用变量时，引用变量地址不变，但变量值可更改；
- static/静态代码块:关键字和线程安不安全没有任何关系,仅表示全局变量且值会被初始化一次，具体是否线程安全看变量是否线程安全
- String的不可变性:String类是final，表明类不可被继承；核心域是private final char[]数组，final表明这个引用所指向的内存地址不会改变，private 保证这个域对外部来说是不可见的，
String对value也进行 保护性拷贝，通过一个Arrays.copyOf的方式拷贝一个数组再给到对象的成员变量char[]数组。
###绝对线程安全
- 不管运行时环境如何，调用者都不需要额外的同步措施
- 绝对线程安全的类，比方说CopyOnWriteArrayList、CopyOnWriteArraySet
###绝对线程安全
- 相对线程安全也就是我们通常意义上所说的线程安全，
###线程非安全
- ArrayList、LinkedList、HashMap等都是线程非安全的类
##线程安全问题
###可见性问题
###有序性问题
- 略，java内存模型篇
###原子性安全问题
- 原子操作多在内涵中使用,单如果不是原子性则导致并发问题（i++）
###活跃性问题(
- 活跃性问题关键在于某件事是否发生，关注最终的结果
- ####死锁问题
  - 判断死锁总结：把每个线程假象成有向图中的一个节点，图中每条边的关系是：“线程A等待线程B所占有的资源”。如果在图中形成了一条环路，那么久存在一个死锁。
  - 死锁条件
      ````
      1.某资源只由某进程占用，此时其他请求者只能等待直至资源释放
      2.进程保持一个资源占用又请求新资源，而新资源被其他线程占用
      3.线程持有资源只能在使用完释放
      4.发生死锁必然存在循环链
      ````
  - 死锁常见形式
    - https://mp.weixin.qq.com/s/W1D8QCvfo2XdLcvqC5Ur-w
    - 两个线程以不同的顺序 来获得相同的锁，应该以相同顺序加锁
    - 动态的锁顺序死锁
      - 案例:A传入a->x对象，b->y对象；B传入a->y对象,b->x对象，线程A进入方法后锁住了第一把锁x对象准备获取y锁的时候，线程B锁住了y对象准备获取x锁，这样就会造成动态死锁，你无法控制外部的传参
      - 解决方案:
         - 1.使用hashcode，每次先锁小的后锁大的，如果出现hash冲突，就再设置一个自己定义的static的锁对象，先用这把static锁锁住保证只有一个线程进入该方法的顺序锁阶段，随后随便设定锁入参a，b即可，因为你保证了只有一个线程操作这个阶段。
         - 2.tryLock（时间）：得不到锁的话就进行释放
    - 多个对象协作发生的死锁
      - 案例:在持有锁时调用某个外部方法(可能加锁)
      - 解决方案:
        - 1.避免锁所作用的范围内调用外部的方法
        - 2.开放调用，即调用某个方法的时候，不需要持有锁，这种调用称为开放调用，缩小锁的粒度，使得同步方法只用来保护真正需要保护的变量或者代码段。
    - 线程饥饿死锁
      - 线程池中，如果任务依赖于其他任务，就可能产生死锁
      - 案例:果任务 A 已经在 Executor 中运行，而任务 A 又向相同的 Executor 中提交了一个任务 B，通常情况下，这样会产生死锁。
      - 解决方案：创建一个B线程池解决问题，B任务在B线程池提交，本质是线程不够。
  - 排查死锁问题
    - 看代码
    - jstack -l pid查看死锁（打印所有线程状态）
  - 死锁修复
    - 杀死进程
    - 获取每个锁的增加时限
- ####活锁问题
  - 在活锁中，两个或多个线程不断在交换彼此的状态，而不是像死锁示例中看到的那样无限等待。
  - 案例:锁的一个很好的例子是消息系统，当发生异常时，消息消费者回滚事务并将消息放回队列的头部。然后从队列中重复读取相同的消息，这又会导致另一个异常并重新被放回队列中。消费者永远不会从队列中获取任何其它消息。

###安全发布
- 安全发布：安全发布是一个对象在使用时，已经完成了初始化。Java对此并没有进行保障，你需要自己进行保障，比如synchronized关键字，原子性、排他性
````
1.在静态初始化函数中初始化一个对象引用 （private static Helper helper = new Helper()）
2.将对象的引用保存到volatile类型的域或者AtomicReferance对象中（利用volatile happen-before规则）
3.将对象的引用保存到某个正确构造对象的final类型域中（初始化安全性）。
4.将对象的引用保存到一个由锁保护的域中（读写都上锁）。
````
###性能问题
- 上下文切换(Context Switch)，这种操作开销很大。
  - 主要有下面几种引起上下文切换的方式。
    - 当前正在执行的任务完成，系统的 CPU 正常调度下一个需要运行的线程。
    - 当前正在执行的任务遇到 I/O 等阻塞操作，线程调度器挂起此任务，继续调度下一个任务。
    - 多个任务并发抢占锁资源，当前任务没有获得锁资源，被线程调度器挂起，继续调度下一个任务。
    - 用户的代码挂起当前任务，比如线程执行 sleep 方法，让出CPU。
    - 使用硬件中断的方式引起上下文切换
- 线程池设置(减少线程切换)
  - 高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换
  - 并发不高、任务执行时间长的业务要区分开看：
    - 假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务
     - corePoolSize = CPU核数 * 2
    - 假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换
  - 并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）
  - 线程池参数设置
    - corePoolSize = maxPoolSize = tasks*taskcost
    - queueCapacity(队列大小) = (coreSizePool/taskcost)*responsetime（容忍响应时间）
    - allowCoreThreadTimeout = false(是否销毁核心线程：否)
    - keepAliveTime = 60s(默认值)
    - rejectedExecutionHandler 拒绝策略
      - 通过实现 RejectedExecutionHandler 接口扩展：单独启动一个新的临时线程来执行任务。
      - AbortPolicy:直接拒绝并抛出异常
      - CallerRunsPolicy:在调用者线程中（也就是说谁把 r 这个任务甩来的），运行当前被丢弃的任务。
##java线程安全实现方式
###互斥同步
- 互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也成为阻塞同步。
- 从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确地同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁
####synchronized
####AQS
###非阻塞同步
####CAS（compareandswap）
- 必须结合volition关键字+CAS实现非阻塞同步
- CAS指令需要有3个操作数，分别是内存地址（在java中理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和新值（用B表示）。CAS指令执行时，CAS指令指令时，当且仅当V处的值符合旧预期值A时，处理器用B更新V处的值，否则它就不执行更新.
- 加入版本号参数可以避免ABA问题
###无需同步方案
####可重入代码
- synchronized拥有锁重入的功能：对象头设置获取锁线程
- AQS拥有锁重入的功能：抢锁成功线程设置独占线程
####线程本地存储
- 如果一段代码中所需的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内。这样无需同步也能保证线程之间不出现数据的争用问题。
  - 一个请求对应一个服务器线程（Thread-per-Request）”的处理方式，这种处理方式的广泛应用使得很多Web服务器应用都可以使用线程本地存储来解决线程安全问题。
- netty 工作线程
####ThreadLocal
- Thread的局部变量ThreadLocalMap，key为ThreadLocal(弱引用)，value为value
- ThreadLocal操作当前线程ThreadLocal对象至线程的ThreadLocalMap
- 当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。从线程的角度看，目标变量就像是线程的本地变量，这也是类名中“Local”所要表达的意思。
- 内存泄漏:
  - ThreadLocalMap中key为ThreadLocal为弱引用，当将ThreadLocal对象（key）设为null，则下次gc key将会回收，但是ThreadLocalMap（thread 的内部属性）生命周期和Thread的一样，它不会回收，这时候就出现了一个现象。那就是ThreadLocalMap的key没了，但是value还在，这就造成了内存泄漏
  - 使用完要remove

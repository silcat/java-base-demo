#线程
##线程状态
###新建状态(New)： 
- 当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行。
###就绪状态(Runnable):
- start()方法返回后，线程就处于就绪状态。
- 一个新创建的线程调用线程的start()方法,当
- 处于就绪状态的线程并不一定立即运行run()方法,线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。
###运行状态(Running)
- 当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法.
### 阻塞状态(Blocked)
- 0>所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。
- 1>线程通过调用sleep方法进入睡眠状态；
- 2>线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；
- 3>线程试图得到一个锁，而该锁正被其他线程持有；
- 4>线程在等待某个触发条件；
### 死亡状态(Dead)
- 有两个原因会导致线程死亡：1) run方法正常退出而自然死亡，2) 一个未捕获的异常终止了run方法而使线程猝死。
- 为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法。如果是可运行或被阻塞，这个方法返回true； 如果线程仍旧是new状态且不是可运行的， 或者线程死亡了，则返回false.
###状态切换
| 表头                 | 是否释放锁    | 线程状态                  |执行后续代码 | 异常处理  | 继续方式                      |实现方式|
|--------------------|----------|-----------------------| ----  | ----  |---------------------------|  ----  |  
| Object.wait()      | 释放锁      | WAITING/TIMED_WAITING | 可能执行后续代码|中断异常 | Object.notify             |native方法|
| Condition.wait()   | 释放锁      | WAITING/TIMED_WAITING        | 可能执行后续代码|中断异常 | Object.notify             |LockPark.park()|
| LockPark.park()    | 不需要获得锁 | WAITING/TIMED_WAITING |一定执行后续代码 | 不抛异常| unpark()                  |unsafe.park|
| Thread.sleep()     | 不释放      |timed_waiting              |一定执行后续代码 | 中断异常| 阻塞时间到了                    |native方法|
| Thread.yield()     | 不释放      | 可运行                   |一定执行后续代码 | 不抛异常| 等待调度                      |native方法|
| childThread.join() | 不释放      | WAITING/TIMED_WAITING |一定执行后续代码 | 中断异常| 子线程运行完毕                   |native方法|
| Thread.interrupt() | -        | 不影响线程状态               |设置线程中断不影响线程的继续执行| | 调用了wait、join、sleep,抛出中断异常 |native方法|
| synchronized       | - 加锁     | blocked                 |一定执行后续代码 | 中断异常| 线程释放monit关键字              |native方法|
##线程创建
- 继承Thread类或者调用Runnable,callble接口,线程池创建线程
- 异同:覆写Runnable接口实现多线程可以避免单继承局限 b.实现Runnable()可以更好的体现共享的概念
##线程安全
###线程安全级别
####不可变
- 不可变:像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用
- 安全发布：安全发布是一个对象在使用时，已经完成了初始化。Java对此并没有进行保障，你需要自己进行保障，比如synchronized关键字，原子性、排他性
````
1.普通变量的创建(new)分为分配内存赋初值，替代引用为真实地址，初始化（真实赋值）三个阶段，这三个不是原子的，对象在分配完内存就其他线程被使用了，其他线程看到的结果可能是错的（未真实赋值）。
2.
````
- final：final天然的就保障了对象的安全发布；final修饰基本数据类型变量时，变量值不改变；final修饰引用变量时，引用变量地址不变，但变量值可更改；
- static/静态代码块:关键字和线程安不安全没有任何关系,仅表示全局变量且值会被初始化一次，具体是否线程安全看变量是否线程安全
- String的不可变性:String类是final，表明类不可被继承；核心域是private final char[]数组，final表明这个引用所指向的内存地址不会改变，private 保证这个域对外部来说是不可见的，
String对value也进行 保护性拷贝，通过一个Arrays.copyOf的方式拷贝一个数组再给到对象的成员变量char[]数组。


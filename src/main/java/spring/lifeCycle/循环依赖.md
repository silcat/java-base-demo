#Spring 如何解决循环依赖的问题
* https://www.jianshu.com/p/8bb67ca11831
* https://blog.csdn.net/wangxuelei036/article/details/104960558
* spring为了解决单例的循环依赖问题，使用了三级缓存，依次从1，2，3缓存获取，
* 对象第一次实例化成功放入3级缓存，在3级缓存获对象成功将缓存放入2级缓存并删除3级缓存，初始化完成放入1级缓存
* A首先完成了初始化的第一步，并且将自己提前曝光到三级缓存中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存(肯定没有，因为A还没初始化完全)，尝试二级缓存（也没有），尝试三级缓存，由于A通过3级缓存将自己提前曝光了，所以B能够通过3级缓存拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了一级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对象完成了初始化。
* 简单来说,就是spring创造了一个 循环依赖的结束点标识
    ## 现象总结：
    * 同样对于循环依赖的场景，构造器注入和prototype类型的属性注入都会初始化Bean失败。
    * 因为@Service默认是单例的，所以单例的属性注入是可以成功的。
#Spring IOC
##三级缓存
* singletonObjects, singletonFactories ,earlySingletonObjects
    * DefaultSingletonBeanRegistry中
    * 普通bean创建完成实例会放入singletonObjects
    * singletonFactories：为了解决setter循环依赖，当实例化bean之后，会将实例化（但未初始化）bean放入其中
    * earlySingletonObjects ：我们可以在其升级为earlySingletonObjects的时候去设置一些属性或者做一些其他事情,我们只需要在 beanA 的类中实现 SmartInstantiationAwareBeanPostProcessor 接口即可
* factoryBeanObjectCache
    * FactoryBeanRegistrySupport
    * 存放FactoryBean生成的实例
* beanDefinitionMap
    * DefaultListableBeanFactory
    * 容器通过registerBeanDefinition()注册到容器    
## 存放FactoryBean与BeanFactory   
* FactoryBean 是一种特殊bean，BeanFactory 就是IOC容器
## Bean的生命周期
* https://blog.csdn.net/qq_39188150/article/details/111364024
* https://blog.csdn.net/chinaleesunnyboy/article/details/107673054
* 启动spring容器，创建applicationcontext
* 加载配置
    * 加载之后,spring容器会将这些配置信息(java bean的信息),封装成BeanDefinition对象
    * AbstractApplicationContext->refresh()
        * 创建AbstractBeanFactory
        * 利用BeanFactoryPostProcessor接口这个扩展点，去对BeanDefinition对象进行一些属性修改
        * 国际化等初始化
* 循环BeanDefinition去实例化
    * springBean的实例化也就是执行bean的构造方法(单例的Bean放入单例池中,但是此刻还未初始化),
    * 在执行实例化的前后,可以通过InstantiationAwareBeanPostProcessor扩展点作用于所有bean)进行一些修改。
    * 执行 @PostConstruct 的方法
* 注入属性
    * 注入autowire注解的属性
* 初始化
    * 对各项属性赋初始化值
    ````  
        (0) 继承Aware接口的执行
        (1) BeanPostProcessor.postProcessBeforeInitialization()
        (2) InitializingBean.afterPropertiesSet()
        (3) 配置文件中指定的 init-method 方法
        (5) BeanPostProcessor.postProcessAfterInitialization()     	   
    ````
* SmartLifecycle start():当对象初始化完成将显示调用start()
    
* 销毁
    * 容器销毁,springbean也会销毁,销毁前后也有一系列的扩展点
    * 销毁bean之前,执行@PreDestroy 的方法
    * 实现DisposableBean方法 
    * 销毁时,执行配置文件或注解中指定的 destroy-method 方法
##java对象在JVM的生命周期
* https://www.jianshu.com/p/825cca41d962
* https://blog.csdn.net/qq_15037231/article/details/102081075
* java对象的生命周期
    ````
    创建阶段(Created)
    应用阶段(In Use)
    不可见阶段(Invisible)
    不可达阶段(Unreachable)
    收集阶段(Collected)
    终结阶段(Finalized)
    对象空间重分配阶段(De-allocated)
    ````
* GCroot:强引用
    * 虚拟机栈中引用的对象
    * 方法区中类静态属性引用的对象:我们在类中使用的static声明的引用类型字段
    * 方法区中常量引用的对象:方法区中常量引用的对象
    * 程序中native本地方法引用的对象
#内存泄漏
https://blog.csdn.net/weter_drop/article/details/89387564
https://www.cnblogs.com/binyue/p/3383555.html
https://www.jianshu.com/p/efec4c77e265
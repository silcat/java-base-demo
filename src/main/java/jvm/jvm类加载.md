#类加载机制
##双亲委派机制
-定义:先找父亲加载，不行再由儿子自己加载
###类加载器
-根类加载器（BootstrapclassLoader）：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如rt.jar、charsets.jar等，BootsTrapClassLoader 写在JVM中，jdk无此类
-扩展类加载器（ExtClassLoader）：负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR类包
-应用加载器（AppClassLoader）：负责加载ClassPath路径下的类包，主要就是加载你自己写的那些类,负责加载用户自定义路径下的类包

###加载器初始化过程
- 类运行加载全过程会创建JVM启动器实例sun.misc.Launcher。sun.misc.Launcher初始化使用了单例模式设计，保证一个JVM虚拟机内只有一个sun.misc.Launcher实例。
- 在Launcher构造方法内部，其创建了两个类加载器，分别是sun.misc.Launcher.ExtClassLoader(扩展类加载器)和sun.misc.Launcher.AppClassLoader(应用类加载器)。
- JVM默认使用launcher的`getClassLoader()`方法返回的类加载器`AppClassLoader`的实例来加载我们的应用程序。
###ExtClassLoader的父加载器为null,但是Bootstrap CLassLoader却可以当成它的父加载器这又是为何呢？
- Bootstrap ClassLoader是由C/C++编写的，它本身是虚拟机的一部分，所以它并不是一个JAVA类，也就是无法在java代码中获取它的引用 ，JVM启动时通过Bootstrap类加载器加载rt.jar等核心jar包中的class文件，之前的int.class,String.class都是由它加载。逻辑上已经先加载一批类
###双亲委派机制
- 应用程序类加载器AppClassLoader加载类调用AppClassLoader的loadClass方法类加载，最终会调用其父类ClassLoader的loadClass方法，果加载过了，就不需要再加载，直接返回，如果类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载，如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的findClass方法来完成类
- 自定义类加载器重写 ClassLoader.findClass（）方法
###破坏双亲委派机制
- 判断是否破坏双亲委派机制的一个重要指标是类加载的请求顺序
- 在 JDBC 4.0以后破坏双亲双亲委派机制：
````
1.支持使用 SPI 的方式来注册 Driver，使用线程上下文类加载器，破坏了双亲委派机制。
2.不向上委派:在 DriverManager 的静态代码块对 Driver进行加载,并没有直接去向上级加载器委派,直接就由AppClassLoader加载器加载好了
3.破坏了全盘负责委托机制:由DriverMangement是在rt.jar包中的，肯定是由Bootstrap ClassLoader加载器加载的,而DriverMangement加载Driver实现类则是直接由线程上下文中的AppClassLoader加载的，违背了全盘负责委托机制中A类调用B类,B类则由A类加载器加载的原则。
````
- 热部署需要破坏双亲委派机制，类和加载器一起换掉
#类加载过程
##加载
- 在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如new对象 等等
- 在加载阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
##验证
- 验证类数据信息是否符合JVM规范，是否是一个有效的字节码文件，验证内容涵盖了类数据信息的格式验证、语义分析、操作验证等。
##准备
- 给类的变量分配内存，并赋予默认值（由于还没有产生对象，实例变量不在此操作范围内）
- 被final修饰的静态变量，会直接赋予原值

##解析
- 将符号引用替换为直接引用，该阶段会把一些静态方法(符号引用，比如main()方法)替换为指向数据 所存内存的指针或句柄等(直接引用)，这是所谓的静态链接过程(类加载期间完成)，
- 动态链接是在程 序运行期间完成的将符号引用替换为直接引用，下节课会讲到动态链接

##初始化
- 将一个类中所有被static关键字标识的代码统一执行一遍，如果执行的是静态变量，那么就会使用用户指定的值覆盖之前在准备阶段设置的初始值；
- 如果执行的是static代码块，那么在初始化阶段，JVM就会执行static代码块中定义的所有操作。
- 所有类变量初始化语句和静态代码块都会在编译时被前端编译器放在收集器里头，存放到一个特殊的方法中，这个方法就是<clinit>方法，即类/接口初始化方法。该方法的作用就是初始化一个中的变量，使用用户指定的值覆盖之前在准备阶段里设定的初始值。任何invoke之类的字节码都无法调用<clinit>方法，因为该方法只能在类加载的过程中由JVM调用。
  如果父类还没有被初始化，那么优先对父类初始化，但在<clinit>方法内部不会显示调用父类的<clinit>方法，由JVM负责保证一个类的<clinit>方法执行之前，它的父类<clinit>方法已经被执行。
  JVM必须确保一个类在初始化的过程中，如果是多线程需要同时初始化它，仅仅只能允许其中一个线程对其执行初始化操作，其余线程必须等待，只有在活动线程执行完对类的初始化操作之后，才会通知正在等待的其他线程。

#java new一个对象发生了什么
* 假设是第一次使用该类，这样的话new一个对象就可以分为两个过程：加载类，初始化类和创建对象
## 加载类
* 由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到JVM内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例
* 加载
  * ClassLoader.loadClass(String name) 方法
  * 使用双亲委派机制 根据一个类的全限定名来读取此类的二进制字节流到JVM内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例。
  * 双亲委派
    * 原因：对于任意一个类，都需要由加载它的类加载器和这个类本身来一同确立其在Java虚拟机中的唯一性，为了保证相同的class文件，在使用的时候，是相同的对象，jvm设计的时候，采用了双亲委派的方式来加载类
    * 流程：通过递归的方式： 子类先委托父类加载 ->父类加载器有自己的加载范围，范围内没有找到，则不加载，并返回给子类->子类在收到父类无法加载的时候，才会自己去加载
    * 分类：boostrapClassLoader<- ExtClassLoader<-AppClassLoader<-自定义ClassLoader
      * Launcher 加载创建了默认加载器
      * AppClassLoader 的父加载器为ExtClassLoader，严格意义上ExtClassLoader没有父加载器，当它找不到会委托boostrapClassLoader寻找
      * 当我们继承ClassLoader实现 自定义加载器默认加载器为AppClassLoader。
      * boostrapClassLoader 是 C++实现的，java获取不到
        * 负责加载<JAVA_HOME>/lib下的类，及jdk下的类
      * ExtClassLoader
        * 负责加载<JAVA_HOME>/lib/ext
        * 设置环境变量：java -Djava.ext.dirs=/tmp/classes 加载指定目录拓展类
      * AppClassLoader
        * 加载java.class.path 目录下的类
      * 自定义ClassLoader
        * 加载java.class.path 目录下的类
        * 实现参考文档：https://www.cnblogs.com/aflyun/p/10618617.html
    * 破坏双亲委派:DriverManager在spi中实现破坏双亲委派。

* 验证
* 准备
  * 为类中的所有静态变量分配内存空间，并为其设置一个初始值（由于还没有产生对象，实例变量不在此操作范围内）
  * 被final修饰的static变量（常量），会直接赋值；

* 解析
  * 将常量池中的符号引用转为直接引用（得到类或者字段、方法在内存中的指针或者偏移量，以便直接调用该方法），这个可以在初始化之后再执行。
  * 注意：
      ````
      验证、准备、解析三个阶段又合称为链接阶段，链接阶段要做的是将加载到JVM中的二进制字节流的类数据信息合并到JVM的运行时状态中。 
      ````  
##初始化类（先父后子）
* 为静态变量赋值
* 执行static代码块。
  * 注意：static代码块只有jvm能够调用
  * 如果是多线程需要同时初始化一个类，仅仅只能允许其中一个线程对其执行初始化操作，其余线程必须等待，只有在活动线程执行完对类的初始化操作之后，才会通知正在等待的其他线程。
* 因为子类存在对父类的依赖，所以类的加载顺序是先加载父类后加载子类，初始化也一样。不过，父类初始化时，子类静态变量的值也有有的，是默认值。
* 最终，方法区会存储当前类类信息，包括类的静态变量、类初始化代码（定义静态变量时的赋值语句 和 静态初始化代码块）、实例变量定义、实例初始化代码（定义实例变量时的赋值语句实例代码块和构造方法）和实例方法，还有父类的类信息引用。
## 创建对象
* 在堆区分配对象需要的内存：分配的内存包括本类和父类的所有实例变量，但不包括任何静态变量
* 对所有实例变量赋默认值:将方法区内对实例变量的定义拷贝一份到堆区，然后赋默认值
* 执行实例初始化代码: 初始化顺序是先初始化父类再初始化子类，初始化时先执行实例代码块然后是构造方法
* 如果有类似于Child c = new Child()形式的c引用的话，在栈区定义Child类型引用变量c，然后将堆区对象的地址赋值给它
* 需要注意的是，每个子类对象持有父类对象的引用，可在内部通过super关键字来调用父类对象，但在外部不可访问    


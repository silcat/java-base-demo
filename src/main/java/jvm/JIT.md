#引用
* https://www.zhihu.com/question/521902218
* https://mp.weixin.qq.com/s/q1sErlGQ9_4PLHXlnwoh1g
#什么是JIT
* ![img.png](synchonize.png)
* 当程序需要首次启动和执行的时候，解释器可以首先发挥作用，一行一行直接转译运行，但效率低下。
* 当多次调用方法或循环体时JIT编译器可以发挥作用，把越来越多的代码编译成本地机器码，之后可以获得更高的效率（占内存），此时就有了智能化的编译器(JIT编译器)
# JIT优化技术
##方法内联
* 所谓方法内联就是把「目标方法」的代码复制到「调用的方法」中，避免发生真实的方法调用候选者：因为每次方法调用都会生成栈帧（压栈出栈记录方法调用位置等等）会带来一定的性能损耗，所以「方法内联」的优化可以提高一定的性能候选者：
* 在JVM中也有相关的参数给予我们指定（-XX:MaxFreqInlineSize、-XX:MaxInlineSize）候选者：
##逃逸分析候选者：
* 「逃逸分析」则是判断一个对象是否被外部方法引用或外部线程访问的分析技术，如果「没有被引用」，就可以对其进行优化，
* 锁消除（同步忽略）：该对象只在方法内部被访问，不会被别的地方引用，那么就一定是线程安全的，可以把锁相关的代码给忽略掉候选者
* 栈上分配：该对象只会在方法内部被访问，直接将对象分配在「栈」中（Java默认是将对象分配在「我去堆」中，是需要通过JVM垃圾回收期进行回收，需要损耗一定的性能，而栈内分配则快很多）候选者
* 标量替换/分离对象：当程序真正执行的时候可以不创建这个对象，而直接创建它的成员变量来代替。将对象拆分后，可以分配对象的成员变量在栈或寄存器上，原本的对象就无需分配内存空间了
* 锁粗化：当有连续的同步代码块使用相同的对象锁，那么就可以使用锁粗化。
## 无用代码消除
##分层编译
* 第0层：程序解释运行。解释器不开启性能监控功能，可触发第1层编译。
* 第1层：即C1编译（客户端编译器）。将字节码编译为本地代码。进行简单和可靠的优化，如有必要将增加性能监控的逻辑。
* 第2层：即C2编译（服务段编译器），将字节码编译为本地代码，同一时候启用一些编译耗时较长的优化，甚至会依据性能监控信息进行一些不可靠的激进优化
# JIT触发原理
* 当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”。
##检测热点代码
* 基于采样的热点探测：采用这种方法的虚拟机会周期性地检查各个线程的栈顶如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”
* 基于计数器的热点探测：采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果次数超过一定的阈值就认为它是“热点方法
* HotSpot使用第二种 - 基于计数器的热点探测方法。
###测热点代码的方式计数
* 计数器的种类（两种共同协作）
* 方法调用计数器：这个计数器用于统计方法被调用的次数。默认阈值在 Client 模式下是 1500 次，在 Server 模式下是 10000 次
* 回边计数器：统计一个方法中循环体代码执行的次数
# TCP/IP协议族分为4层
* 参考文档：https://mp.weixin.qq.com/s/5PhLWZ4Z9kagZSBlhzcLAg
* ![img.png](osi-model-detail.png) 
##应用层：
* 主要是与应用通信使用到的协议，
* 比如：FTP、DNS、HTTP
##传输层
* 为应用层提供在两台机器之间数据传输
* TCP
    * 通过三次握手建立连接后开始传输数据
    ````
    第一次握手：建立连接时，客户端发送 syn 包(syn=j)到服务器，并进入 SYN_SEND 状态，等待服务器确认；
    第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=j+1），同时自己也发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；
    第三次握手：客户端收到服务器的 SYN＋ACK 包，向服务器发送确认包 ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手
    ````
    * 为什么是三次握手，而不是两次或者4次呢
    ````
    假如说是两次握手，如果客户端自己处理异常或者是服务器返回的ack消息丢失，那么客服端会认为连接建立失败，再次重新发送请求建立连接，但是服务端却无感知，以为连接以及正常建立，导致服务器建立无用的连接，浪费资源  
    假如四次握手，如果三次已经足够，那就不需要四次了。如果四次的话，最后一个ACK丢失，那么又会出现两次握手的问题。
    ````
    * 通过四次挥手断开连接
    ````
    客户端向服务器发送FIN希望断开连接请求。
    服务器向客户端发送ACK，表示同意释放连接。
    服务器向客户端发送一个FIN表示希望断开连接。
    客户端向服务器返回一个ACK表示同意释放连接。
    ````
    * 为什么断开连接需要四次而不是三次呢
    ````
    因为当服务器收到客户端断开连接的请求后，服务器不能立即断开连接，因为可能服务器端还有数据未发送完成，所以只能回复一个ACK表示我已收到消息；等服务器端数据发送完成之后再发送一个FIN希望断开连接的消息，客户端回复ACK之后，就可以安全断开了
    ````
* UDP
    * UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，不需要三次和四次挥手
    * TCP 保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。
##TCP粘包与半包
* TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾
* 原因：
    * 发送方原因TCP默认使用Nagle算法：收集多个小分组，在一个确认到来时一起发送
    * 接收方原因:TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。
* 解决
    * 每条数据有固定的格式（开始符，结束符），这种方法简单易行，
    * 送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置    
* netty解决方式
    * LengthFieldBasedFrameDecoder
    * 编码解码处理器计算长度
* http协议解决方式
    * 格式固定以/r/n作为结束标志
    * 请求头或响应头的Content-Length，单位是字节；
##UDP为什么不会粘包为什么不可靠
* UDP有明确的结束标志，不会有粘包的，UDP本身有对数据完整性的校验，不完整的包会被丢弃，所以也不会不完整。
* TCP 保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。   
##网络层
* 使用IP协议，arp协议
* 涉及设备：路由器
* 主要解决由于本地交换机无法存储全世界那么多MAC地址，通过网络层连接非局域网设备
* 关键流程
   * 本层设备会使用IP地址通信
   * 路由器作为一台独立的拥有 MAC 地址的设备，向下连接交换机
   * 本地IP会通过交换机通信，非本地IP发送到路由器（由子网掩码判断是否是本地IP）
   * 在本机上要设置默认网关，非本地IP会请求会进行转发至默认网关，默认网关的IP地址就是路由器IP地址
   * 路由器只知道目标IP地址，路由器通过arp协议把目标 IP 地址对应的 MAC 地址找到，路由器便找到目标设备进行通信
  
## 数据链路层
* 使用以太网协议
* 涉及设备：网卡，交换器等
* 主要解决局域网通信
* 关键流程：每台设备网卡都有唯一MAC 地址，设备使用交换器通过MAC地址互相通信

#一次完整的HTTP事务是怎样一个过程？
* 参考文档： https://blog.51cto.com/linux5588/1351007
* 具体过程
    * 域名解析：浏览器DNS缓存->操作DNS缓存->host文件-> 浏览器发起配置首选DNS服务器营商的DNS服务器->结果返回给Windows系统内核->内核又把结果返回给浏览器，最终获取 对应的IP地址
    * 发起TCP的3次握手
    * 建立TCP连接后发起http请求
    * 服务器响应http请求，浏览器得到html代码 
    * 浏览器解析html代码，并向服务器请求html代码中的资源（如js、css、图片等）
    * 浏览器对页面进行渲染呈现给用户
    
#HTTP请求报文与响应报文格式
## 请求报文：
* 请求行：包含请求方法、URI、HTTP版本信息
* 请求首部字段
* 请求内容实体
##响应报文：
* 状态行：包含HTTP版本、状态码、状态码的原因短语
* 响应首部字段
* 响应内容实体


#为什么说Http协议无状态协议？怎么解决Http协议无状态？
* 本身HTTP协议是不保存状态的，自身不对请求和响应直接的通信状态进行保存，所以是无状态的协议。因为在有些场景下我们需要保存用户的登录信息，所以引入了cookie来管理状态。客户端第一次请求服务器的时候，服务器会生成cookie添加在响应头里面，以后客户端的每次请求都会带上这个cookie信息。
* cookie与session
````
1、我们需要知道cookie在客户端，session在服务端，cookie的产生是在服务端产生的
2、cookie只是一个通行证，但并不是安全的，任何安全的校验必须要在服务端上完成，cookie只是存在客户端上面的一个唯一标识它且由服务端定制的信息，本地可以改，但是不管怎么改，最后还是需要把它拿上发送给服务端进行匹配校验
3、session和cookie的存储都存在时效性，这是很有必要的
4、单个cookie保存的数据不能超过4kb，很多浏览器都限制了一个站点最多保存20个cookie
5、不管是cookie还是session，都是建立在安全性的大前提下，session中不仅仅有cookie的信息，同时会有该用户的相关重要且安全的信息存储，所以session是在服务器的，而cookie只是服务器将一些不重要的信息拿出来丢给客户的存在，以备以后快速匹配校验用。
````
  
# uri和url的区别？
* URI 是统一资源标识符，
* URL 是统一资源定位符,
* URN是统一资源名称 ，它命名资源但不指定如何定位资源 。
* 每个 URL 都是 URI，但不一定每个 URI 都是 URL这是因为 URI 还包括一个子类，即统一资源名称 (URN)， 
* URI 和 URL 都定义了 what the resource is。URL 还定义了 how to get the resource。

#Get和Post区别
* get请求参数跟在url后面，有长度限制(浏览器长度限制，如果是内部的get请求则不限制长度)，post请求参数封装在请求头中，无长度限制。
* get请求参数暴露，安全性保密性没有post高
* get请求会被浏览器缓存起来(解决办法一般是在get请求后面添加一些随机数，比如说时间戳；这样每次请求都会当做新的请求去访问后台)，post请求内容不会被缓存
* get请求是幂等请求,post是非幂等请求

#Http如何实现持久连接的呢？
* HTTP/1.1的连接默认情况下都是持久连接。如果要显式关闭，需要在报文中加上Connection:Close首部。即在HTTP/1.1中，所有的连接都进行了复用

#大文件的断点续传是如何实现的呢
* HTTP请求头有个Range字段；我们下载文件的时候如果遇到网络中断，如果重头开始下载会浪费时间，所以我们可以从上一次中断处继续开始下载；

#HTTP状态码
* 2xx: 成功状态码，表示请求正常处理完毕
* 3xx: 重定向状态码，表示需要附加操作才能完成成请求
    * 讲讲304缓存的原理
        * 第一步：判断当前缓存是否过期：1、Expires；2、Cache-Contro
        * 第二步：判断服务器中的文件是否有改动：Last-Modified & if-modified-since。
* 4xx: 客户端错误状态码
* 5xx: 服务器错误状态码

# HTTP优点缺点
* HTTP/1.0一次只允许在一个TCP连接上发起一个请求，HTTP/1.1使用的流水线技术也只能部分处理请求并发，仍然会存在队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟。
* 单向请求，只能由客户端发起。
* 请求报文与响应报文首部信息冗余量大。
* 数据未压缩，导致数据的传输量大
* 通信使用明文不加密，内容可能被窃听
* 不验证通信方身份，可能遭到伪装
* 无法验证报文完整性，可能被篡改 HTTPS就是HTTP加上SSL加密处理（一般是SSL安全通信线路）+认证+完整性保护
#什么是队头阻塞，怎么解决
* 队头阻塞”与短连接和长连接无关，而是由 HTTP 基本的“请求 - 应答”模型所导致的。
* HTTP 请求会形成了一个先进先出的“串行”队列。
* 如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，这就是队头阻塞。
* 因为“请求 - 应答”模型不能变，所以“队头阻塞”问题在 HTTP/1.1 里无法解决，只能缓解
    * 并发请求，同时对一个域名发起多个长连接，用数量来解决质量的问题
    * 域名分片（domain sharding）技术：还是用数量来解决质量的思路。HTTP 协议和浏览器不是限制并发连接数量吗？好，那我就多开几个域名，比如 shard1.chrono.com、shard2.chrono.com，而这些域名都指向同一台服务器 www.chrono.com，这样实际长连接的数量就又上去了
#什么是正向代理，反向代理，中间人攻击？
* 正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端.
    * 访问原来无法访问的资源，如google
    * 可以做缓存，加速访问资源
    *对客户端访问授权，上网进行认证
    4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息
* 反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端
    * 保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网
    * 负载均衡，通过反向代理服务器来优化网站的负载

# 常见web攻击
* 参考文档：https://www.cnblogs.com/morethink/p/8734103.html
* XSS
* SQL注入
* DDOS
* CSRF
# HTTP优化方案
* TCP复用：TCP连接复用是将多个客户端的HTTP请求复用到一个服务器端TCP连接上，而HTTP复用则是一个客户端的多个HTTP请求通过一个TCP连接进行处理。前者是负载均衡设备的独特功能；而后者是HTTP 1.1协议所支持的新功能，目前被大多数浏览器所支持。
* 内容缓存：将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了。
* 压缩：将文本数据进行压缩，减少带宽
* SSL加速（SSL Acceleration）：使用SSL协议对HTTP协议进行加密，在通道内加密并加速
* TCP缓冲：通过采用TCP缓冲技术，可以提高服务器端响应时间和处理效率，减少由于通信链路问题给服务器造成的连接负担。

#HTTP与RPC异同
* 从传输协议来说：RPC既可以基于TCP也可以基于HTTP协议，但是HTTP通常都是基于HTTP
* 从性能消耗来说: RPC可以基于thrift实现高效二进制传输。HTTP大部分通过json实现，无论从字节大小还是序列化耗时都比t'hrift耗时
* 从负载均衡来说: RPC基本上自带负载均衡策略，而HTTP需要配置Nginx实现。

# 关于Http 2.0 你知道多少？ 
* 参考文档：https://segmentfault.com/a/1190000016656529
##SPDY协议
* Http 2.0主要基于SPDY协议
* SPDY是Speedy的昵音，意为“更快”。它是Google开发的基于TCP协议的应用层协议。目标是优化HTTP协议的性能，通过压缩、多路复用和优先级等技术，缩短网页的加载时间并提高安全性。SPDY协议的核心思想是尽量减少TCP连接数。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。
##HTTP2.0特点
* 二进制传输
* 多路复用   
* Header压缩
* 服务器Push
* 更安全
##如何使用HTTP2.0
* https://blog.csdn.net/qq_32447301/article/details/94299686
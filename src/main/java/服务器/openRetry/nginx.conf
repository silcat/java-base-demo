
#user  nobody;
worker_processes  1;

error_log  logs/error.log;
#error_log  logs/error.log  notice;



events {
    worker_connections  1024;
}


http {
    access_log  logs/access.log  ;
    sendfile        on;
    #keepalive_timeout  0;
    keepalive_timeout  65;
	lua_package_path '$prefix/lua/?.lua;$prefix/lualib/?.lua;$prefix/lua/cjson/?.lua;;';
    lua_package_cpath "$prefix/lua/test/?.so;$prefix/lualib/?.so;;";

    #共享字典，也就是本地缓存，名称叫做：item_cache，大小150m
    lua_shared_dict cache 150m;

    # 在生产环境上务必确保 lua_code_cache 设置成 on。
    lua_code_cache on;

    #负载均衡
    upstream bakend {
         server 127.0.0.1:8003 weight=10;
         server 127.0.0.1:8002 weight=10;
    }

    server {
        listen       80;
        server_name  localhost;
        location / {
            root   html;
            index  index.html index.htm;
        }

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

    }

    #例子
    server {
        listen       8002;
        server_name  localhost;
        # 默认读取 body Nginx 是为了解决负载均衡场景诞生的，所以它默认是不读取 body 的行为
        lua_need_request_body on;

        location = /api/helloworld {
                content_by_lua_block {
                    ngx.say("HelloWorld")
                }
        }
        location = /testbakend {
                                 content_by_lua_block {
                                     ngx.say("8002")
                                       ngx.flush()
                                 }
                         }
         location = /api/getParam {
                    content_by_lua_block {
                               local arg = ngx.req.get_uri_args()
                               for k,v in pairs(arg) do
                                   ngx.say("[GET ] key:", k, " v:", v)
                               end

                               ngx.req.read_body()
                               local arg = ngx.req.get_post_args()
                               for k,v in pairs(arg) do
                                   ngx.say("[POST] key:", k, " v:", v)
                               end
                }
        }
        location = /api/response {
                 content_by_lua_block {
                                 ngx.say("hello")
                                 ngx.sleep(3)
                                 ngx.say("the world")
                             }
            }

        location = /api/response2 {
                  content_by_lua_block {
                                 ngx.say("hello")
                                 ngx.flush() -- 显式的向客户端刷新响应输出
                                 ngx.sleep(3)
                                 ngx.say("the world")
                             }
                }
        location = /api/responsetable {
                          content_by_lua_block {
                                 local table = {
                                      "hello, ", {"world: ", true, " or ", false,{": ", nil}}
                                  }
                                 ngx.print(table)
                             }
                 }

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
     }

    server {
        listen       8003;
        server_name  localhost;

        lua_need_request_body on;
         location = /testbakend {
                                 content_by_lua_block {
                                     ngx.say("8003")
                                      ngx.flush()
                                 }
                         }

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
       }
    }

     #cach
     server {
        listen       8006;
        server_name  localhost;

       location ~ /api/item/(\d+){
                       # 默认的响应类型
                       default_type application/json;
                       # 响应结果由lua/item.lua文件来决定
                       content_by_lua_file lua/test/item.lua;
                   }
         location /testbakend {
                        proxy_pass  http://bakend;
                    }

      }


}

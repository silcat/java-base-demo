
     
##缓存应该注意的问题
* 缓存雪崩
    * 于系统 A，假设本来缓存在高峰期可以扛住4000 QPS，单机数据库最大支持每秒2000QPS，但是缓存机器意外发生了全盘宕机或同时失效，数据库必然扛不住，然后就挂了。此时，如果没用什么特别的方案来处理这个故障，重启数据库，但是数据库立马又被新的流量给打死了。
    * 处理方式
        * 批量往Redis存数据的时候，把每个Key的失效时间都加个随机值就好了，避免缓存同时失效
        * 如果redis是集群部署，将热点数据均匀分布在不同的Redis库中也能避免全部失效的问题 
        * 设置热点数据永远不过期，有更新操作就更新缓存就好了
        * 除了redis，本地用 ehcache 缓存 + hystrix 限流&降级 ，先查ehcache 缓存缓存不存在再查数据库
        * redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据
* 缓存穿透
    * 对于系统A，假如不做参数校验，每次请求不存在数据库中也不存在缓存中，每次都这样，并发高点就容易崩掉了 
    * 处理方式
        * 通过bitMap进行参数校验，不存在数据库的请求直接拦截
        * 数据库不存在缓存中设置一个空值，设置过期时间
* 缓存击穿
    * 对于系统A，假如每秒5000个请求中4000个请求都是请求同一个key，则当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库            
    * 处理方式
        * 设置热点数据永远不过期
        * 读取数据库加上分布式锁
* 缓存与数据库双写的一致性 
    * 先更新数据库，再更新缓存（不可取）
     ````
     原因一（线程安全角度） 同时有请求A和请求B进行更新操作，那么会出现
     
     （1）线程A更新了数据库
     （2）线程B更新了数据库
     （3）线程B更新了缓存
     （4）线程A更新了缓存
     这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。
     原因二（业务场景角度） 有如下两点：
     
     （1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。
     （2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。
     ````
    * 先删缓存，再更新数据库（不可取）
    ````
    该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:
    （1）请求A进行写操作，删除缓存
    （2）请求B查询发现缓存不存在
    （3）请求B去数据库查询得到旧值
    （4）请求B将旧值写入缓存
    （5）请求A将新值写入数据库 上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。
    那么，如何解决呢？采用延时双删策略 伪代码如下
    ````
    * 非读写分离框架: 先删缓存，再更新数据库,休眠1秒后删除缓存，如此可以将脏数据删除（可取）
    ````
    如果你用了mysql的读写分离架构？
    造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。   
    （1）请求A进行写操作，删除缓存
    （2）请求A将数据写入数据库了，
    （3）请求B查询缓存发现，缓存没有值
    （4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值
    （5）请求B将旧值写入缓存
    （6）数据库完成主从同步，从库变为新值 上述情形，就是数据不一致的原因。。
    采用这种同步淘汰策略，吞吐量降低怎么办？
    ````
    * 读写分离：先删缓存，再更新数据库,休眠 1秒+主从同步时间 后删除缓存，但依旧第二次存在删除缓存导致的数据不一致
    * 先更新数据库，异步延时删除缓存，若缓存删除失败则重试
##实例解析


